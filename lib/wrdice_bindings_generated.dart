// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `src/wrdice.h`.
///
/// Regenerate bindings with `dart run ffigen --config ffigen.yaml`.
///
class WrdiceBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
  _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  WrdiceBindings(ffi.DynamicLibrary dynamicLibrary)
    : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  WrdiceBindings.fromLookup(
    ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup,
  ) : _lookup = lookup;

  ffi.Pointer<Army> alloc_army() {
    return _alloc_army();
  }

  late final _alloc_armyPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<Army> Function()>>('alloc_army');
  late final _alloc_army = _alloc_armyPtr
      .asFunction<ffi.Pointer<Army> Function()>();

  ffi.Pointer<SimStats> alloc_simstats() {
    return _alloc_simstats();
  }

  late final _alloc_simstatsPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SimStats> Function()>>(
        'alloc_simstats',
      );
  late final _alloc_simstats = _alloc_simstatsPtr
      .asFunction<ffi.Pointer<SimStats> Function()>();

  void free_army(ffi.Pointer<Army> army) {
    return _free_army(army);
  }

  late final _free_armyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<Army>)>>(
        'free_army',
      );
  late final _free_army = _free_armyPtr
      .asFunction<void Function(ffi.Pointer<Army>)>();

  void free_simstats(ffi.Pointer<SimStats> stats) {
    return _free_simstats(stats);
  }

  late final _free_simstatsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SimStats>)>>(
        'free_simstats',
      );
  late final _free_simstats = _free_simstatsPtr
      .asFunction<void Function(ffi.Pointer<SimStats>)>();

  void run_simulation(
    ffi.Pointer<Army> army_a,
    ffi.Pointer<Army> army_b,
    ffi.Pointer<SimStats> stats,
    bool with_force_advantage,
    bool with_batch_cap,
  ) {
    return _run_simulation(
      army_a,
      army_b,
      stats,
      with_force_advantage,
      with_batch_cap,
    );
  }

  late final _run_simulationPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<Army>,
            ffi.Pointer<Army>,
            ffi.Pointer<SimStats>,
            ffi.Bool,
            ffi.Bool,
          )
        >
      >('run_simulation');
  late final _run_simulation = _run_simulationPtr
      .asFunction<
        void Function(
          ffi.Pointer<Army>,
          ffi.Pointer<Army>,
          ffi.Pointer<SimStats>,
          bool,
          bool,
        )
      >();
}

final class BattleResult extends ffi.Struct {
  @ffi.Float()
  external double win_a;

  @ffi.Float()
  external double win_b;

  @ffi.Float()
  external double draw;

  @ffi.Float()
  external double death;
}

final class Survived extends ffi.Struct {
  @ffi.Uint32()
  external int size;

  @ffi.Array.multi([256])
  external ffi.Array<ffi.Uint32> count;

  @ffi.Array.multi([256])
  external ffi.Array<ffi.Float> odds;
}

final class Stats extends ffi.Struct {
  @ffi.Array.multi([5])
  external ffi.Array<Survived> stats_lnd;

  @ffi.Array.multi([5])
  external ffi.Array<Survived> stats_air;

  @ffi.Array.multi([5])
  external ffi.Array<Survived> stats_sea;
}

final class SimStats extends ffi.Struct {
  external Stats army_a;

  external Stats army_b;

  external BattleResult br;
}

final class Stance extends ffi.Struct {
  @ffi.Array.multi([5])
  external ffi.Array<ffi.Uint32> stance_off;

  @ffi.Array.multi([5])
  external ffi.Array<ffi.Uint32> stance_def;
}

final class Army extends ffi.Struct {
  @ffi.Array.multi([5])
  external ffi.Array<ffi.Uint32> n_units_lnd;

  @ffi.Array.multi([5])
  external ffi.Array<ffi.Uint32> n_units_air;

  @ffi.Array.multi([5])
  external ffi.Array<ffi.Uint32> n_units_sea;

  external Stance stance_lnd;

  external Stance stance_air;

  external Stance stance_sea;
}

final class HP extends ffi.Struct {
  @ffi.Array.multi([5])
  external ffi.Array<ffi.Uint32> hp_stance_off;

  @ffi.Array.multi([5])
  external ffi.Array<ffi.Uint32> hp_stance_def;
}

final class ArmyHP extends ffi.Struct {
  external HP lnd;

  external HP air;

  external HP sea;
}
