// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `src/wrdice.h`.
///
/// Regenerate bindings with `dart run ffigen --config ffigen.yaml`.
///
class WrdiceBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
  _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  WrdiceBindings(ffi.DynamicLibrary dynamicLibrary)
    : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  WrdiceBindings.fromLookup(
    ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup,
  ) : _lookup = lookup;

  void get_dice_for_army(ffi.Pointer<Army> army, ffi.Pointer<Dice> dice) {
    return _get_dice_for_army(army, dice);
  }

  late final _get_dice_for_armyPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Army>, ffi.Pointer<Dice>)
        >
      >('get_dice_for_army');
  late final _get_dice_for_army = _get_dice_for_armyPtr
      .asFunction<void Function(ffi.Pointer<Army>, ffi.Pointer<Dice>)>();

  void run_simulation(
    ffi.Pointer<Army> army_a,
    ffi.Pointer<Army> army_b,
    ffi.Pointer<SimStats> stats,
    bool with_force_advantage,
    bool with_batch_cap,
  ) {
    return _run_simulation(
      army_a,
      army_b,
      stats,
      with_force_advantage,
      with_batch_cap,
    );
  }

  late final _run_simulationPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<Army>,
            ffi.Pointer<Army>,
            ffi.Pointer<SimStats>,
            ffi.Bool,
            ffi.Bool,
          )
        >
      >('run_simulation');
  late final _run_simulation = _run_simulationPtr
      .asFunction<
        void Function(
          ffi.Pointer<Army>,
          ffi.Pointer<Army>,
          ffi.Pointer<SimStats>,
          bool,
          bool,
        )
      >();
}

final class BattleResult extends ffi.Struct {
  @ffi.Float()
  external double win_a;

  @ffi.Float()
  external double win_b;

  @ffi.Float()
  external double draw;

  @ffi.Float()
  external double death;
}

final class Survived extends ffi.Struct {
  @ffi.Uint32()
  external int size;

  @ffi.Array.multi([256])
  external ffi.Array<ffi.Uint32> count;

  @ffi.Array.multi([256])
  external ffi.Array<ffi.Float> odds;
}

final class Stats extends ffi.Struct {
  @ffi.Array.multi([5])
  external ffi.Array<Survived> stats_lnd;

  @ffi.Array.multi([5])
  external ffi.Array<Survived> stats_air;

  @ffi.Array.multi([5])
  external ffi.Array<Survived> stats_sea;
}

final class SimStats extends ffi.Struct {
  external Stats army_a;

  external Stats army_b;

  external BattleResult br;
}

final class Stance extends ffi.Struct {
  @ffi.Array.multi([5])
  external ffi.Array<ffi.Uint32> stance_off;

  @ffi.Array.multi([5])
  external ffi.Array<ffi.Uint32> stance_def;
}

final class Army extends ffi.Struct {
  @ffi.Array.multi([5])
  external ffi.Array<ffi.Uint32> n_units_lnd;

  @ffi.Array.multi([5])
  external ffi.Array<ffi.Uint32> n_units_air;

  @ffi.Array.multi([5])
  external ffi.Array<ffi.Uint32> n_units_sea;

  external Stance stance_lnd;

  external Stance stance_air;

  external Stance stance_sea;
}

final class HP extends ffi.Struct {
  @ffi.Array.multi([5])
  external ffi.Array<ffi.Uint32> hp_stance_off;

  @ffi.Array.multi([5])
  external ffi.Array<ffi.Uint32> hp_stance_def;
}

final class ArmyHP extends ffi.Struct {
  external HP lnd;

  external HP air;

  external HP sea;
}

final class DiceDistribution extends ffi.Struct {
  @ffi.Array.multi([5])
  external ffi.Array<ffi.Uint32> vs_air;

  @ffi.Array.multi([5])
  external ffi.Array<ffi.Uint32> vs_gnd;
}

final class Dice extends ffi.Struct {
  external DiceDistribution air;

  external DiceDistribution lnd;

  external DiceDistribution sea;
}
